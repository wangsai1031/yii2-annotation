<?php
/**
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

namespace yii\web;

use Yii;
use yii\base\Component;
use yii\base\Exception;

/**
 * AssetConverter 支持将几种流行的脚本格式转换为JS或CSS脚本
 * AssetConverter supports conversion of several popular script formats into JS or CSS scripts.
 *
 * 在资源发布之后，AssetManager 使用它来转换文件。
 * It is used by [[AssetManager]] to convert files after they have been published.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 */
class AssetConverter extends Component implements AssetConverterInterface
{
    /**
     * 用于执行资产转换的命令。
     * 键是资产文件扩展名，值是对应的目标脚本类型(“css”或“js”)和用于转换的命令。
     * @var array the commands that are used to perform the asset conversion.
     * The keys are the asset file extension names, and the values are the corresponding
     * target script types (either "css" or "js") and the commands used for the conversion.
     *
     * 您还可以使用路径别名来指定命令的位置
     * You may also use a [path alias](guide:concept-aliases) to specify the location of the command:
     *
     * ```php
     * [
     *     'styl' => ['css', '@app/node_modules/bin/stylus < {from} > {to}'],
     * ]
     * ```
     */
    public $commands = [
        'less' => ['css', 'lessc {from} {to} --no-color --source-map'],
        'scss' => ['css', 'sass {from} {to} --sourcemap'],
        'sass' => ['css', 'sass {from} {to} --sourcemap'],
        'styl' => ['css', 'stylus < {from} > {to}'],
        'coffee' => ['js', 'coffee -p {from} > {to}'],
        'ts' => ['js', 'tsc --out {to} {from}'],
    ];
    /**
     * 是否在转换结果已经存在的情况下强性对资源文件进行转换
     * @var bool whether the source asset file should be converted even if its result already exists.
     * You may want to set this to be `true` during the development stage to make sure the converted
     * assets are always up-to-date. Do not set this to true on production servers as it will
     * significantly degrade the performance.
     */
    public $forceConvert = false;


    /**
     * 将一个给定的资产文件转换为一个CSS或JS文件。
     * Converts a given asset file into a CSS or JS file.
     * 资产文件路径，相对于$basePath
     * @param string $asset the asset file path, relative to $basePath
     * @param string $basePath the directory the $asset is relative to.
     * 返回：转换后的资产文件路径，相对于$basePath。
     * @return string the converted asset file path, relative to $basePath.
     */
    public function convert($asset, $basePath)
    {
        // 查找 '.' 在 $asset 中最后出现的位置
        $pos = strrpos($asset, '.');
        if ($pos !== false) {
            // 获取扩展名
            $ext = substr($asset, $pos + 1);
            // 若用于执行资产转换的命令列表中存在该扩展名
            if (isset($this->commands[$ext])) {
                // 获取转换后的扩展名和相应的转换命令
                list($ext, $command) = $this->commands[$ext];
                // 转换后的文件完整路径
                $result = substr($asset, 0, $pos + 1) . $ext;
                // 转换后的文件最后修改时间小于源文件最后修改时间，或者开启了强制转换
                if ($this->forceConvert || @filemtime("$basePath/$result") < @filemtime("$basePath/$asset")) {
                    // 运行命令来转换资产文件。
                    $this->runCommand($command, $basePath, $asset, $result);
                }

                return $result;
            }
        }

        // 若不需要转换，则返回源文件
        return $asset;
    }

    /**
     * 运行命令来转换资产文件。
     * Runs a command to convert asset files.
     * 要运行的命令。如果前缀为`@`,它将被当作路径别名
     * @param string $command the command to run. If prefixed with an `@` it will be treated as a [path alias](guide:concept-aliases).
     * 资产基础路径和命令工作目录
     * @param string $basePath asset base path and command working directory
     * 资产文件的名称
     * @param string $asset the name of the asset file
     * 由转换器命令生成的文件的名称
     * @param string $result the name of the file to be generated by the converter command
     * @return bool true on success, false on failure. Failures will be logged.
     * @throws \yii\base\Exception when the command fails and YII_DEBUG is true.
     * In production mode the error will be logged.
     */
    protected function runCommand($command, $basePath, $asset, $result)
    {
        // 从别名中获取命令
        $command = Yii::getAlias($command);

        // 替换命令中的占位符
        $command = strtr($command, [
            /**
             * @see http://php.net/manual/zh/function.escapeshellarg.php
             * escapeshellarg() : 把字符串转码为可以在 shell 命令里使用的参数
             */
            '{from}' => escapeshellarg("$basePath/$asset"),
            '{to}' => escapeshellarg("$basePath/$result"),
        ]);
        $descriptor = [
            1 => ['pipe', 'w'],
            2 => ['pipe', 'w'],
        ];
        $pipes = [];
        /**
         * @see http://php.net/manual/zh/function.proc-open.php
         * proc_open(): 执行一个命令，并且打开用来输入/输出的文件指针。
         *
         * $command: 要执行的命令.
         * $descriptor: 一个索引数组。 数组的键表示描述符，数组元素值表示 PHP 如何将这些描述符传送至子进程。
         *              0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。
         * $pipes: 将被置为索引数组， 其中的元素是被执行程序创建的管道对应到 PHP 这一端的文件指针。
         * $basePath: 要执行命令的初始工作目录。 必须是 绝对 路径， 设置此参数为 NULL 表示使用默认值（当前 PHP 进程的工作目录）。
         */
        $proc = proc_open($command, $descriptor, $pipes, $basePath);
        /**
         * http://php.net/manual/zh/function.stream-get-contents.php
         * stream_get_contents — 读取资源流到一个字符串
         * 与 file_get_contents() 一样，但是 stream_get_contents() 是对一个已经打开的资源流进行操作，并将其内容写入一个字符串返回.
         */
        $stdout = stream_get_contents($pipes[1]);
        $stderr = stream_get_contents($pipes[2]);
        // 遍历 $pipes，挨个关闭文件
        foreach ($pipes as $pipe) {
            fclose($pipe);
        }
        // 关闭命令资源
        $status = proc_close($proc);

        if ($status === 0) {
            Yii::debug("Converted $asset into $result:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr", __METHOD__);
        } elseif (YII_DEBUG) {
            throw new Exception("AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr");
        } else {
            Yii::error("AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr", __METHOD__);
        }

        return $status === 0;
    }
}
